<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>登月模拟器 (Lunar Lander)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: #0f172a;
            color: #e2e8f0;
            overflow: hidden;
            touch-action: none; /* 防止移动端触摸滚动 */
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
        }

        canvas {
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            border: 2px solid #334155;
            background-color: transparent;
        }

        .ui-overlay {
            position: absolute;
            pointer-events: none;
            width: 800px;
            height: 600px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        .hud-text {
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.7);
        }

        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 23, 42, 0.95);
            border: 2px solid #475569;
            padding: 2rem;
            text-align: center;
            border-radius: 1rem;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            pointer-events: auto;
            display: none; /* 默认隐藏 */
            min-width: 300px;
        }

        .modal.active {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -40%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }

        .btn {
            background: #2563eb;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            text-transform: uppercase;
        }

        .btn:hover {
            background: #1d4ed8;
            transform: scale(1.05);
        }

        .status-good { color: #4ade80; }
        .status-warn { color: #facc15; }
        .status-bad { color: #ef4444; }

        /* 移动端控制提示 */
        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #64748b;
            font-size: 0.8rem;
            opacity: 0.6;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- 游戏画布 -->
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <!-- HUD 界面 -->
        <div class="ui-overlay">
            <div class="flex justify-between w-full">
                <div>
                    <div class="text-xl text-green-400 hud-text">FUEL</div>
                    <div class="w-32 h-4 bg-gray-800 border border-gray-600 mt-1">
                        <div id="fuel-bar" class="h-full bg-green-500 w-full transition-all duration-75"></div>
                    </div>
                </div>
                <div class="text-right">
                    <div class="text-xl text-green-400 hud-text">ALTITUDE: <span id="alt-val" class="text-white">1000</span></div>
                    <div class="text-sm text-gray-400">SCORE: <span id="score-val">0</span></div>
                </div>
            </div>

            <div class="flex justify-between items-end w-full">
                <div class="text-left">
                    <div class="text-sm text-gray-400">HORIZONTAL SPD</div>
                    <div id="h-speed" class="text-xl font-bold">0.0 m/s</div>
                </div>
                
                <!-- 姿态仪模拟 -->
                <div class="flex flex-col items-center">
                    <div class="text-xs text-gray-500 mb-1">ANGLE</div>
                    <div id="angle-val" class="text-xl font-bold">0°</div>
                </div>

                <div class="text-right">
                    <div class="text-sm text-gray-400">VERTICAL SPD</div>
                    <div id="v-speed" class="text-xl font-bold">0.0 m/s</div>
                </div>
            </div>
        </div>

        <!-- 结算弹窗 -->
        <div id="game-modal" class="modal">
            <h2 id="modal-title" class="text-3xl font-bold text-white mb-2">MISSION ACCOMPLISHED</h2>
            <p id="modal-desc" class="text-gray-300 mb-4">Perfect landing.</p>
            <div id="modal-stats" class="text-sm bg-gray-800 p-3 rounded mb-4 text-left font-mono">
                <!-- 统计数据 -->
            </div>
            <button class="btn" onclick="resetGame()">PLAY AGAIN</button>
        </div>
        
        <div class="controls-hint">
            Controls: [W/↑] Thrust | [A/D] Rotate | [←/→] Side Thrust
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const fuelBar = document.getElementById('fuel-bar');
        const altVal = document.getElementById('alt-val');
        const hSpeedVal = document.getElementById('h-speed');
        const vSpeedVal = document.getElementById('v-speed');
        const angleVal = document.getElementById('angle-val');
        const modal = document.getElementById('game-modal');
        
        // 游戏常量
        const GRAVITY = 0.05;
        const THRUST_POWER = 0.12;
        const SIDE_THRUST_POWER = 0.05;
        const ROTATION_SPEED = 0.04;
        const LANDING_PAD_WIDTH = 120;
        const SAFE_LANDING_SPEED = 2.0; // 垂直速度阈值
        const SAFE_HORIZONTAL_SPEED = 1.0; // 水平速度阈值
        const SAFE_ANGLE = 0.2; // 弧度 (~11度)
        
        // 游戏状态
        let gameState = 'START'; // START, PLAYING, WON, CRASHED
        let particles = [];
        let stars = [];
        let terrain = [];
        let score = 0;

        // 登月舱对象
        const lander = {
            x: 400,
            y: 50,
            width: 20,
            height: 25,
            vx: 0,
            vy: 0,
            angle: 0,
            fuel: 100,
            thrusting: false,
            rotatingLeft: false,
            rotatingRight: false,
            sideThrustLeft: false,
            sideThrustRight: false,
            crashed: false,
            landed: false
        };

        // 按键监听
        const keys = {};

        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if(gameState === 'START') startGame();
        });

        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        function handleInput() {
            if (gameState !== 'PLAYING') return;

            // 旋转 (A/D)
            if (keys['KeyA']) lander.angle -= ROTATION_SPEED;
            if (keys['KeyD']) lander.angle += ROTATION_SPEED;

            // 主引擎 (W or Up Arrow)
            lander.thrusting = (keys['KeyW'] || keys['ArrowUp']) && lander.fuel > 0;
            
            // 侧推 (Arrow Left/Right)
            lander.sideThrustLeft = keys['ArrowLeft'] && lander.fuel > 0;
            lander.sideThrustRight = keys['ArrowRight'] && lander.fuel > 0;

            if (lander.thrusting || lander.sideThrustLeft || lander.sideThrustRight) {
                lander.fuel = Math.max(0, lander.fuel - 0.2);
            }
        }

        function initStars() {
            stars = [];
            for(let i=0; i<150; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2,
                    brightness: Math.random()
                });
            }
        }

        function generateTerrain() {
            terrain = [];
            const padX = canvas.width / 2 - LANDING_PAD_WIDTH / 2;
            const segments = 20;
            const segmentWidth = canvas.width / segments;

            // 生成月球表面点
            for (let i = 0; i <= segments; i++) {
                let x = i * segmentWidth;
                let y;

                // 确保中间是平坦的着陆区
                if (x >= padX && x <= padX + LANDING_PAD_WIDTH) {
                    y = canvas.height - 50;
                } else {
                    // 随机地形，但稍微平滑一点
                    y = canvas.height - 50 - (Math.random() * 80); 
                }
                terrain.push({x, y});
            }
            // 确保着陆平台的确切点
            // 我们通过物理碰撞检测单独处理平台，这里只是为了视觉绘制
        }

        function resetGame() {
            lander.x = canvas.width / 2;
            lander.y = 80;
            lander.vx = (Math.random() - 0.5) * 1.5; // 随机初始水平速度
            lander.vy = 0;
            lander.angle = 0;
            lander.fuel = 100;
            lander.crashed = false;
            lander.landed = false;
            
            particles = [];
            modal.classList.remove('active');
            gameState = 'PLAYING';
            
            generateTerrain();
            loop();
        }

        function startGame() {
            initStars();
            generateTerrain();
            resetGame();
        }

        function createParticle(x, y, angle, speed, life, color) {
            particles.push({
                x, y, 
                vx: Math.cos(angle) * speed + (Math.random() - 0.5), 
                vy: Math.sin(angle) * speed + (Math.random() - 0.5),
                life, 
                maxLife: life,
                color
            });
        }

        function updatePhysics() {
            if (gameState !== 'PLAYING') return;

            // 重力
            lander.vy += GRAVITY;

            // 主引擎推力 (沿着角度方向)
            if (lander.thrusting) {
                // angle 0 是向上。Canvas 0度通常是向右，但我们要符合直觉。
                // x分量: sin(angle), y分量: -cos(angle) (因为y向下是正)
                lander.vx += Math.sin(lander.angle) * THRUST_POWER;
                lander.vy -= Math.cos(lander.angle) * THRUST_POWER;

                // 产生粒子
                for(let i=0; i<3; i++) {
                    // 粒子从底部喷出 (相反方向)
                    let pAngle = lander.angle + Math.PI / 2; // 基础方向修正
                    // 粒子喷射方向 = lander.angle + PI (反向)
                    // 使用简单的坐标变换计算喷口位置
                    let bottomX = lander.x + Math.sin(lander.angle) * 15;
                    let bottomY = lander.y + Math.cos(lander.angle) * 15;
                    
                    createParticle(bottomX, bottomY, lander.angle + Math.PI / 2 + (Math.random()-0.5), 3, 20, '#fbbf24');
                }
            }

            // 侧向推力 (RCS) - 总是垂直于船体

            // 左推 (ArrowLeft) -> 向左加速 (修正后)
            if (lander.sideThrustLeft) {
                // 负号加速 X 和 Y
                lander.vx -= Math.cos(lander.angle) * SIDE_THRUST_POWER;
                lander.vy -= Math.sin(lander.angle) * SIDE_THRUST_POWER;
                // 粒子从右侧喷出 (推动飞船向左)
                createParticle(lander.x + Math.cos(lander.angle)*10, lander.y + Math.sin(lander.angle)*10, lander.angle + Math.PI, 1.5, 10, '#ffffff');
            }

            // 右推 (ArrowRight) -> 向右加速 (修正后)
            if (lander.sideThrustRight) {
                // 正号加速 X 和 Y
                lander.vx += Math.cos(lander.angle) * SIDE_THRUST_POWER;
                lander.vy += Math.sin(lander.angle) * SIDE_THRUST_POWER;
                // 粒子从左侧喷出 (推动飞船向右)
                createParticle(lander.x - Math.cos(lander.angle)*10, lander.y - Math.sin(lander.angle)*10, lander.angle, 1.5, 10, '#ffffff');
            }

            // 更新位置
            lander.x += lander.vx;
            lander.y += lander.vy;

            // 边界检查 (左右循环或阻挡)
            if (lander.x < 0) lander.x = canvas.width;
            if (lander.x > canvas.width) lander.x = 0;
            
            // 顶部阻挡
            if (lander.y < 0) {
                lander.y = 0;
                lander.vy = 0;
            }

            checkCollision();
        }

        function checkCollision() {
            // 地面高度检测
            // 简单起见，我们定义着陆平台高度固定为 canvas.height - 50
            const groundLevel = canvas.height - 50;
            
            // 检查是否接触地面
            if (lander.y + 10 >= groundLevel) { // +10 是半个高度大致修正
                lander.y = groundLevel - 10;
                
                // 检查是否在平台上
                const padCenterX = canvas.width / 2;
                const onPad = Math.abs(lander.x - padCenterX) < (LANDING_PAD_WIDTH / 2);

                if (onPad) {
                    // 在平台上，检查着陆参数
                    const speed = Math.sqrt(lander.vx*lander.vx + lander.vy*lander.vy);
                    const safeSpeed = lander.vy < SAFE_LANDING_SPEED && Math.abs(lander.vx) < SAFE_HORIZONTAL_SPEED;
                    const safeAngle = Math.abs(lander.angle) < SAFE_ANGLE;

                    if (safeSpeed && safeAngle) {
                        gameWin();
                    } else {
                        // 撞击速度、角度不安全
                        let reason = "Unsafe Landing: ";
                        if (!safeSpeed) reason += `Speed: ${lander.vy.toFixed(1)} m/s (Max ${SAFE_LANDING_SPEED.toFixed(1)}) `;
                        if (!safeAngle) reason += `Angle: ${(lander.angle * 180 / Math.PI).toFixed(0)}° (Max ${(SAFE_ANGLE * 180 / Math.PI).toFixed(0)}°)`;
                        gameCrash(reason);
                    }
                } else {
                    // 不在平台上，撞击不平整地面
                    gameCrash("Missed the Landing Zone");
                }
            }
        }

        function gameCrash(reason) {
            gameState = 'CRASHED';
            lander.crashed = true;
            // 爆炸效果
            for(let i=0; i<50; i++) {
                createParticle(lander.x, lander.y, Math.random() * Math.PI * 2, Math.random() * 5, 50, '#ef4444');
            }
            showModal('MISSION FAILED', `CRASHED: ${reason}`, false);
        }

        function gameWin() {
            gameState = 'WON';
            lander.landed = true;
            // 增加分数
            const fuelBonus = Math.floor(lander.fuel * 10);
            score += 1000 + fuelBonus;
            showModal('SUCCESS!', `Safe landing! Fuel Bonus: ${fuelBonus}`, true);
        }

        function showModal(title, desc, success) {
            document.getElementById('modal-title').innerText = title;
            document.getElementById('modal-title').className = success ? 'text-3xl font-bold text-green-400 mb-2' : 'text-3xl font-bold text-red-500 mb-2';
            document.getElementById('modal-desc').innerText = desc;
            
            // 显示详细数据
            const statsHtml = `
                <div>Vertical Speed: ${lander.vy.toFixed(2)} m/s</div>
                <div>Horizontal Speed: ${lander.vx.toFixed(2)} m/s</div>
                <div>Angle: ${(lander.angle * 180 / Math.PI).toFixed(1)}°</div>
                <div>Fuel Remaining: ${Math.floor(lander.fuel)}%</div>
            `;
            document.getElementById('modal-stats').innerHTML = statsHtml;

            modal.classList.add('active');
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function draw() {
            // 清空
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 画星星
            ctx.fillStyle = '#ffffff';
            stars.forEach(star => {
                ctx.globalAlpha = Math.random() * 0.5 + 0.3;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            // 画地形
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            for (let point of terrain) {
                ctx.lineTo(point.x, point.y);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.fillStyle = '#475569';
            ctx.fill();
            ctx.strokeStyle = '#94a3b8';
            ctx.stroke();

            // 画着陆平台 (高亮)
            const padX = canvas.width / 2 - LANDING_PAD_WIDTH / 2;
            const padY = canvas.height - 50;
            ctx.fillStyle = '#166534'; // green-800
            ctx.fillRect(padX, padY, LANDING_PAD_WIDTH, 10);
            ctx.strokeStyle = '#4ade80'; // green-400
            ctx.lineWidth = 2;
            ctx.strokeRect(padX, padY, LANDING_PAD_WIDTH, 10);
            
            // 平台标记文字
            ctx.fillStyle = '#4ade80';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('LANDING ZONE', canvas.width/2, padY + 25);

            // 画粒子
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.beginPath();
                ctx.arc(p.x, p.y, Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            // 画登月舱
            if (!lander.crashed) {
                ctx.save();
                ctx.translate(lander.x, lander.y);
                ctx.rotate(lander.angle);

                // 舱体 (主体)
                ctx.fillStyle = '#e2e8f0'; // slate-200
                ctx.beginPath();
                ctx.ellipse(0, 0, 12, 12, 0, 0, Math.PI*2); // 圆形驾驶舱
                ctx.fill();
                
                // 支架底座
                ctx.fillStyle = '#f59e0b'; // amber-500
                ctx.fillRect(-12, 5, 24, 6);

                // 脚架
                ctx.strokeStyle = '#94a3b8';
                ctx.lineWidth = 2;
                ctx.beginPath();
                // 左脚
                ctx.moveTo(-10, 8);
                ctx.lineTo(-18, 18);
                ctx.lineTo(-22, 18);
                // 右脚
                ctx.moveTo(10, 8);
                ctx.lineTo(18, 18);
                ctx.lineTo(22, 18);
                ctx.stroke();

                // 推进器火焰 (如果在推)
                if (lander.thrusting && Math.random() > 0.2) {
                    ctx.fillStyle = '#ef4444'; // red core
                    ctx.beginPath();
                    ctx.moveTo(-6, 11);
                    ctx.lineTo(0, 25 + Math.random() * 10);
                    ctx.lineTo(6, 11);
                    ctx.fill();
                }

                ctx.restore();
            }

            // 更新 HUD DOM
            updateHUD();
        }

        function updateHUD() {
            fuelBar.style.width = `${lander.fuel}%`;
            if (lander.fuel < 20) fuelBar.classList.replace('bg-green-500', 'bg-red-500');
            else fuelBar.classList.replace('bg-red-500', 'bg-green-500');

            // 高度 (反转坐标系)
            let alt = Math.max(0, (canvas.height - 50) - lander.y - 10).toFixed(0);
            altVal.innerText = alt;
            document.getElementById('score-val').innerText = score;

            // 速度与角度显示颜色逻辑
            const hSpeed = lander.vx.toFixed(1);
            const vSpeed = lander.vy.toFixed(1); // 正数向下
            const angleDeg = (lander.angle * 180 / Math.PI).toFixed(0);

            hSpeedVal.innerText = `${hSpeed} m/s`;
            hSpeedVal.className = Math.abs(lander.vx) > SAFE_HORIZONTAL_SPEED ? 'text-xl font-bold status-bad' : 'text-xl font-bold status-good';

            vSpeedVal.innerText = `${vSpeed} m/s`;
            // 如果在下降且速度快
            vSpeedVal.className = (lander.vy > SAFE_LANDING_SPEED) ? 'text-xl font-bold status-bad' : 'text-xl font-bold status-good';

            angleVal.innerText = `${angleDeg}°`;
            angleVal.className = Math.abs(lander.angle) > SAFE_ANGLE ? 'text-xl font-bold status-bad' : 'text-xl font-bold status-good';
        }

        function loop() {
            if (gameState === 'START') {
                // 显示开始画面? 这里简单起见直接重置
                startGame(); 
                return; 
            }

            handleInput();
            updatePhysics();
            updateParticles();
            draw();

            if (gameState === 'PLAYING') {
                requestAnimationFrame(loop);
            }
        }

        // 初始启动
        resetGame();

    </script>
</body>
</html>