<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>登月模拟器：极速挑战</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: #0f172a;
            color: #e2e8f0;
            overflow: hidden;
            touch-action: none; /* 防止移动端触摸滚动 */
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column; 
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
        }

        /* 调整 Canvas 大小以适应手机视图 */
        #gameCanvas {
            max-width: 100%;
            max-height: calc(100vh - 120px); 
            aspect-ratio: 8 / 6; 
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            border: 2px solid #334155;
            background-color: transparent;
        }

        .ui-overlay {
            position: absolute;
            pointer-events: none;
            /* HUD 尺寸与 Canvas 尺寸保持一致 */
            width: min(100%, 800px); 
            height: min(calc(100vh - 120px), 600px);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }
        
        /* 强制覆盖固定宽度，确保 HUD 内容不被压缩 */
        @media (min-width: 800px) {
            .ui-overlay {
                width: 800px;
                height: 600px;
            }
        }

        .hud-text {
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.7);
        }

        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 23, 42, 0.95);
            border: 2px solid #475569;
            padding: 2rem;
            text-align: center;
            border-radius: 1rem;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            pointer-events: auto;
            display: none; /* 默认隐藏 */
            min-width: 300px;
            z-index: 100;
        }

        .modal.active {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -40%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }

        .btn {
            background: #2563eb;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            text-transform: uppercase;
        }

        .btn:hover {
            background: #1d4ed8;
            transform: scale(1.05);
        }

        .status-good { color: #4ade80; }
        .status-warn { color: #facc15; }
        .status-bad { color: #ef4444; }

        /* 移动端控制布局 */
        .touch-controls {
            position: absolute;
            bottom: 0;
            width: min(100%, 800px); /* 与游戏画布保持宽度一致 */
            height: 120px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            pointer-events: auto;
            /* 桌面隐藏，手机显示 */
            display: none; 
        }

        /* 屏幕宽度小于 800px 时显示触摸控制 */
        @media (max-width: 799px) {
            .touch-controls {
                display: flex;
            }
            .controls-hint {
                display: none !important; /* 在手机上隐藏键盘提示 */
            }
        }
        
        .control-btn {
            background-color: rgba(30, 41, 59, 0.8); /* slate-800 semi-transparent */
            color: #fff;
            border: 2px solid #475569;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            touch-action: manipulation; /* 提高触摸响应 */
            transition: background-color 0.1s;
        }
        
        .control-btn:active, .control-btn.active-touch {
            background-color: #2563eb; /* blue-600 */
            border-color: #3b82f6;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }

        .side-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .main-thrust-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- 游戏画布 -->
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <!-- HUD 界面 -->
        <div class="ui-overlay">
            <div class="flex justify-between w-full">
                <div>
                    <div class="text-xl text-green-400 hud-text">FUEL</div>
                    <div class="w-32 h-4 bg-gray-800 border border-gray-600 mt-1">
                        <div id="fuel-bar" class="h-full bg-green-500 w-full transition-all duration-75"></div>
                    </div>
                </div>
                <div class="text-right">
                    <div class="text-xl text-green-400 hud-text">ALTITUDE: <span id="alt-val" class="text-white">1000</span></div>
                    <div class="text-sm text-gray-400">SCORE: <span id="score-val">0</span></div>
                    <div class="text-sm text-gray-400">TIME: <span id="timer-val" class="text-yellow-400">0.00s</span></div>
                </div>
            </div>

            <div class="flex justify-between items-end w-full">
                <div class="text-left">
                    <div class="text-sm text-gray-400">HORIZONTAL SPD</div>
                    <div id="h-speed" class="text-xl font-bold">0.0 m/s</div>
                </div>
                
                <!-- 姿态仪模拟 -->
                <div class="flex flex-col items-center">
                    <div class="text-xs text-gray-500 mb-1">ANGLE</div>
                    <div id="angle-val" class="text-xl font-bold">0°</div>
                </div>

                <div class="text-right">
                    <div class="text-sm text-gray-400">VERTICAL SPD</div>
                    <div id="v-speed" class="text-xl font-bold">0.0 m/s</div>
                </div>
            </div>
        </div>
        
        <!-- 启动/倒计时遮罩 -->
        <div id="start-overlay" class="modal active">
            <h2 class="text-3xl font-bold text-yellow-300 mb-4">LUNAR LANDER CHALLENGE</h2>
            <p class="text-gray-300 mb-6">
                任务目标: 在 <span class="text-red-400 font-bold">10.0 秒内</span> 安全着陆于平台！<br>
                <span class="text-green-400">5.0 秒内着陆将解锁烟花表演！</span>
            </p>
            <div id="countdown-display" class="text-6xl font-extrabold text-white hidden">3</div>
            <button id="start-btn" class="btn mt-4">请求陀螺仪权限并开始</button>
            <div id="gyro-status" class="text-sm text-gray-400 mt-2">点击开始，然后倾斜手机来控制旋转。</div>
        </div>

        <!-- 结算弹窗 -->
        <div id="game-modal" class="modal">
            <h2 id="modal-title" class="text-3xl font-bold text-white mb-2">MISSION ACCOMPLISHED</h2>
            <p id="modal-desc" class="text-gray-300 mb-4">Perfect landing.</p>
            <div id="modal-stats" class="text-sm bg-gray-800 p-3 rounded mb-4 text-left font-mono">
                <!-- 统计数据 -->
            </div>
            <button class="btn" onclick="resetGame(true)">PLAY AGAIN</button>
        </div>
        
        <!-- 桌面控制提示 -->
        <div class="controls-hint absolute bottom-5 text-gray-500 text-xs opacity-60">
            Controls (Keyboard): [W/↑] Thrust | [A/D] Rotate | [←/→] Side Thrust
        </div>
        
        <!-- 移动端触摸控制区域 -->
        <div class="touch-controls">
            <!-- 左侧控制：侧推左 & 旋转左 -->
            <div class="side-controls">
                <button id="btn-side-left" class="control-btn">&#9664;</button> <!-- 左箭头 -->
                <div class="text-xs text-gray-400 text-center -mt-1">H-Thrust</div>
                <button id="btn-rotate-left" class="control-btn text-xl">A</button>
                <div class="text-xs text-gray-400 text-center -mt-1">Rotate</div>
            </div>

            <!-- 中间控制：主推力 -->
            <div class="main-thrust-group">
                <div class="text-xl text-green-400 hud-text">THRUST</div>
                <button id="btn-thrust" class="control-btn w-20 h-20 text-3xl bg-green-700/80 border-green-400 hover:bg-green-600 active:bg-green-400 active-touch:bg-green-400">&#9650;</button> <!-- 上箭头 -->
                <div class="text-sm text-gray-400 mt-2">Tap/Hold to Start</div>
            </div>

            <!-- 右侧控制：侧推右 & 旋转右 -->
            <div class="side-controls">
                <button id="btn-side-right" class="control-btn">&#9654;</button> <!-- 右箭头 -->
                <div class="text-xs text-gray-400 text-center -mt-1">H-Thrust</div>
                <button id="btn-rotate-right" class="control-btn text-xl">D</button>
                <div class="text-xs text-gray-400 text-center -mt-1">Rotate</div>
            </div>
        </div>

    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const fuelBar = document.getElementById('fuel-bar');
        const altVal = document.getElementById('alt-val');
        const hSpeedVal = document.getElementById('h-speed');
        const vSpeedVal = document.getElementById('v-speed');
        const angleVal = document.getElementById('angle-val');
        const modal = document.getElementById('game-modal');
        
        // 游戏常量
        const GRAVITY = 0.05;
        const THRUST_POWER = 0.12;
        const SIDE_THRUST_POWER = 0.05;
        const ROTATION_SPEED = 0.04;
        const LANDING_PAD_WIDTH = 120;
        const SAFE_LANDING_SPEED = 2.0; // 垂直速度阈值
        const SAFE_HORIZONTAL_SPEED = 1.0; // 水平速度阈值
        const SAFE_ANGLE = 0.2; // 弧度 (~11度)
        const MAX_LANDING_TIME = 10.0; // 10秒时间限制
        const FIREWORKS_LANDING_TIME = 5.0; // 5秒烟花触发

        // 游戏状态
        let gameState = 'START'; // START, COUNTDOWN, PLAYING, WON, CRASHED
        let particles = [];
        let stars = [];
        let terrain = [];
        let score = 0;
        let gyroEnabled = false;
        let rotationInput = 0; // Gyro rotation input

        // 登月舱对象
        const lander = {
            x: 400,
            y: 50,
            width: 20,
            height: 25,
            vx: 0,
            vy: 0,
            angle: 0,
            fuel: 50, // 燃料减半
            thrusting: false,
            rotatingLeft: false,
            rotatingRight: false,
            sideThrustLeft: false,
            sideThrustRight: false,
            crashed: false,
            landed: false,
            startTime: 0,
            elapsedTime: 0
        };

        // --- 输入处理状态 ---
        const keys = {};
        const touchState = {
            thrust: false,
            rotateLeft: false,
            rotateRight: false,
            sideThrustLeft: false,
            sideThrustRight: false
        };

        // --- 键盘事件监听 ---
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // --- 陀螺仪控制 ---
        function requestOrientationPermission() {
            const gyroStatus = document.getElementById('gyro-status');
            const btnRotateLeft = document.getElementById('btn-rotate-left');
            const btnRotateRight = document.getElementById('btn-rotate-right');

            if (typeof DeviceOrientationEvent !== 'undefined') {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    // iOS 13+ logic
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            if (response == 'granted') {
                                gyroEnabled = true;
                                window.addEventListener('deviceorientation', handleGyro);
                                btnRotateLeft.style.display = 'none';
                                btnRotateRight.style.display = 'none';
                                gyroStatus.innerText = '陀螺仪: 激活 (倾斜手机旋转)';
                            } else {
                                gyroEnabled = false;
                                btnRotateLeft.style.display = 'flex';
                                btnRotateRight.style.display = 'flex';
                                gyroStatus.innerText = '陀螺仪: 拒绝 (使用屏幕 A/D 按钮)';
                            }
                        })
                        .catch(err => {
                            console.error("Gyro permission request failed:", err);
                            gyroStatus.innerText = '陀螺仪: 错误 (使用屏幕 A/D 按钮)';
                        });
                } else {
                    // Non-iOS 13+ browsers (Android, etc.)
                    gyroEnabled = true;
                    window.addEventListener('deviceorientation', handleGyro);
                    btnRotateLeft.style.display = 'none';
                    btnRotateRight.style.display = 'none';
                    gyroStatus.innerText = '陀螺仪: 激活 (倾斜手机旋转)';
                }
            } else {
                gyroEnabled = false;
                btnRotateLeft.style.display = 'flex';
                btnRotateRight.style.display = 'flex';
                gyroStatus.innerText = '陀螺仪: 不支持 (使用屏幕 A/D 按钮)';
            }
        }

        function handleGyro(event) {
            // event.gamma typically corresponds to side-to-side tilt (roll)
            const tiltAngle = event.gamma || 0; 
            const maxTilt = 30; // 30 degrees of tilt is max input
            
            // Map tilt angle to rotation input value (-1 to 1)
            rotationInput = Math.max(-1, Math.min(1, tiltAngle / maxTilt));
        }

        // --- 触摸事件监听 (Mobile) ---
        const buttons = {
            'btn-thrust': 'thrust',
            'btn-side-left': 'sideThrustLeft',
            'btn-side-right': 'sideThrustRight',
            'btn-rotate-left': 'rotateLeft', // Fallback
            'btn-rotate-right': 'rotateRight', // Fallback
        };

        function setupTouchControls() {
            Object.keys(buttons).forEach(id => {
                const btn = document.getElementById(id);
                const control = buttons[id];
                if (!btn) return;

                btn.addEventListener('mousedown', (e) => e.preventDefault()); 

                const startHandler = (e) => {
                    e.preventDefault();
                    if (gameState === 'PLAYING') {
                        touchState[control] = true;
                    }
                    btn.classList.add('active-touch');
                };
                
                const releaseHandler = (e) => {
                    e.preventDefault();
                    touchState[control] = false;
                    btn.classList.remove('active-touch');
                };

                btn.addEventListener('touchstart', startHandler, { passive: false });
                btn.addEventListener('touchend', releaseHandler, { passive: false });
                btn.addEventListener('touchcancel', releaseHandler, { passive: false });
            });
        }
        
        // --- 主输入逻辑：合并键盘、触摸和陀螺仪 ---
        function handleInput() {
            if (gameState !== 'PLAYING') return;

            // 旋转 (Gyro or Keyboard/Touch fallback)
            if (gyroEnabled) {
                // 陀螺仪控制旋转
                lander.angle += rotationInput * ROTATION_SPEED * 1.5;
                // 仅用于火焰显示
                lander.rotatingLeft = rotationInput < -0.1; 
                lander.rotatingRight = rotationInput > 0.1;
            } else {
                // 键盘/触摸控制旋转
                lander.rotatingLeft = keys['KeyA'] || touchState.rotateLeft;
                lander.rotatingRight = keys['KeyD'] || touchState.rotateRight;
                
                if (lander.rotatingLeft) lander.angle -= ROTATION_SPEED;
                if (lander.rotatingRight) lander.angle += ROTATION_SPEED;
            }
            
            // 主引擎 (W/Up Arrow or Touch)
            lander.thrusting = (keys['KeyW'] || keys['ArrowUp'] || touchState.thrust) && lander.fuel > 0;
            
            // 侧推 (Left/Right Arrow or Touch)
            lander.sideThrustLeft = (keys['ArrowLeft'] || touchState.sideThrustLeft) && lander.fuel > 0;
            lander.sideThrustRight = (keys['ArrowRight'] || touchState.sideThrustRight) && lander.fuel > 0;

            if (lander.thrusting || lander.sideThrustLeft || lander.sideThrustRight) {
                lander.fuel = Math.max(0, lander.fuel - 0.2);
            }
        }

        // --- 游戏核心函数 ---
        
        function initStars() {
            stars = [];
            for(let i=0; i<150; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2,
                    brightness: Math.random()
                });
            }
        }

        function generateTerrain() {
            terrain = [];
            const padX = canvas.width / 2 - LANDING_PAD_WIDTH / 2;
            const segments = 20;
            const segmentWidth = canvas.width / segments;

            // 生成月球表面点
            for (let i = 0; i <= segments; i++) {
                let x = i * segmentWidth;
                let y;

                // 确保中间是平坦的着陆区
                if (x >= padX && x <= padX + LANDING_PAD_WIDTH) {
                    y = canvas.height - 50;
                } else {
                    y = canvas.height - 50 - (Math.random() * 80); 
                }
                terrain.push({x, y});
            }
        }

        function resetGame(shouldStart = false) {
            lander.x = canvas.width / 2;
            lander.y = 80;
            lander.vx = (Math.random() - 0.5) * 1.5; 
            lander.vy = 0;
            lander.angle = 0;
            lander.fuel = 50; // 燃料重置
            lander.crashed = false;
            lander.landed = false;
            lander.startTime = 0;
            lander.elapsedTime = 0;
            score = 0;
            
            particles = [];
            modal.classList.remove('active');
            
            generateTerrain();

            if (shouldStart) {
                 // 如果是"PLAY AGAIN"按钮触发，直接进入倒计时
                startGame(); 
            }
        }

        function startCountdown() {
            gameState = 'COUNTDOWN';
            const countdownDisplay = document.getElementById('countdown-display');
            let count = 3;
            countdownDisplay.innerText = count;
            countdownDisplay.classList.remove('hidden');
            document.getElementById('start-overlay').classList.add('active');

            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownDisplay.innerText = count;
                } else if (count === 0) {
                    countdownDisplay.innerText = 'GO!';
                } else {
                    clearInterval(countdownInterval);
                    document.getElementById('start-overlay').classList.remove('active');
                    
                    // 倒计时结束后开始游戏
                    gameState = 'PLAYING';
                    lander.startTime = Date.now();
                }
            }, 1000); 
        }

        function startGame() {
            // 设置启动按钮逻辑
            document.getElementById('start-overlay').classList.add('active');
            document.getElementById('start-btn').style.display = 'block';
            document.getElementById('countdown-display').classList.add('hidden');

            document.getElementById('start-btn').onclick = () => {
                requestOrientationPermission(); 
                document.getElementById('start-btn').style.display = 'none';
                resetGame(false); // 仅重置状态，不启动游戏循环
                startCountdown();
            };
        }

        function createParticle(x, y, angle, speed, life, color) {
            particles.push({
                x, y, 
                vx: Math.cos(angle) * speed + (Math.random() - 0.5), 
                vy: Math.sin(angle) * speed + (Math.random() - 0.5),
                life, 
                maxLife: life,
                color
            });
        }

        function updatePhysics() {
            if (gameState !== 'PLAYING') return;

            lander.elapsedTime = (Date.now() - lander.startTime) / 1000;
            
            // 重力
            lander.vy += GRAVITY;

            // 主引擎推力
            if (lander.thrusting) {
                lander.vx += Math.sin(lander.angle) * THRUST_POWER;
                lander.vy -= Math.cos(lander.angle) * THRUST_POWER;

                // 产生粒子
                for(let i=0; i<3; i++) {
                    let bottomX = lander.x + Math.sin(lander.angle) * 15;
                    let bottomY = lander.y + Math.cos(lander.angle) * 15;
                    createParticle(bottomX, bottomY, lander.angle + Math.PI / 2 + (Math.random()-0.5), 3, 20, '#fbbf24');
                }
            }

            // 侧向推力 (RCS)
            if (lander.sideThrustLeft) {
                lander.vx -= Math.cos(lander.angle) * SIDE_THRUST_POWER;
                lander.vy -= Math.sin(lander.angle) * SIDE_THRUST_POWER;
                createParticle(lander.x + Math.cos(lander.angle)*10, lander.y + Math.sin(lander.angle)*10, lander.angle + Math.PI, 1.5, 10, '#ffffff');
            }

            if (lander.sideThrustRight) {
                lander.vx += Math.cos(lander.angle) * SIDE_THRUST_POWER;
                lander.vy += Math.sin(lander.angle) * SIDE_THRUST_POWER;
                createParticle(lander.x - Math.cos(lander.angle)*10, lander.y - Math.sin(lander.angle)*10, lander.angle, 1.5, 10, '#ffffff');
            }

            // 更新位置
            lander.x += lander.vx;
            lander.y += lander.vy;

            // 边界检查 (左右循环)
            if (lander.x < 0) lander.x = canvas.width;
            if (lander.x > canvas.width) lander.x = 0;
            
            // 顶部阻挡
            if (lander.y < 0) {
                lander.y = 0;
                lander.vy = 0;
            }

            checkCollision();
        }

        function checkCollision() {
            const groundLevel = canvas.height - 50;
            
            if (lander.y + 10 >= groundLevel) {
                lander.y = groundLevel - 10;
                
                const padCenterX = canvas.width / 2;
                const onPad = Math.abs(lander.x - padCenterX) < (LANDING_PAD_WIDTH / 2);

                if (onPad) {
                    const safeSpeed = lander.vy < SAFE_LANDING_SPEED && Math.abs(lander.vx) < SAFE_HORIZONTAL_SPEED;
                    const safeAngle = Math.abs(lander.angle) < SAFE_ANGLE;

                    if (safeSpeed && safeAngle) {
                        gameWin();
                    } else {
                        let reason = "Unsafe Landing: ";
                        if (!safeSpeed) reason += `Speed: ${lander.vy.toFixed(1)} m/s (Max ${SAFE_LANDING_SPEED.toFixed(1)}) `;
                        if (!safeAngle) reason += `Angle: ${(lander.angle * 180 / Math.PI).toFixed(0)}° (Max ${(SAFE_ANGLE * 180 / Math.PI).toFixed(0)}°)`;
                        gameCrash(reason);
                    }
                } else {
                    gameCrash("Missed the Landing Zone");
                }
            }
        }

        function gameCrash(reason) {
            gameState = 'CRASHED';
            lander.crashed = true;
            for(let i=0; i<50; i++) {
                createParticle(lander.x, lander.y, Math.random() * Math.PI * 2, Math.random() * 5, 50, '#ef4444');
            }
            showModal('任务失败', `坠毁: ${reason}`, false);
        }

        function gameWin() {
            const landingTime = lander.elapsedTime;
            
            // 5秒时间限制失败判定
            if (landingTime > MAX_LANDING_TIME) {
                gameCrash(`着陆时间过长: ${landingTime.toFixed(1)}s (限制 ${MAX_LANDING_TIME.toFixed(1)}s)`);
                return;
            }

            gameState = 'WON';
            lander.landed = true;
            
            let title = '任务成功！';
            let desc = `安全着陆，耗时: ${landingTime.toFixed(2)}s。`;
            let bonusScore = 1000;
            let fireworks = false;

            // 5秒极速着陆判定
            if (landingTime <= FIREWORKS_LANDING_TIME) {
                title = '完美着陆！(烟花盛宴)';
                desc = `极速着陆! 耗时: ${landingTime.toFixed(2)}s。你是一位登月之神!`;
                bonusScore = 5000;
                fireworks = true;
                // 添加大量粒子 (烟花)
                for(let i=0; i<100; i++) {
                    createParticle(lander.x, lander.y, Math.random() * Math.PI * 2, Math.random() * 8, 80, `hsl(${Math.random() * 360}, 100%, 50%)`);
                }
            }

            const fuelBonus = Math.floor(lander.fuel * 20); // 燃料奖励更高
            score += bonusScore + fuelBonus;

            showModal(title, desc, true, fuelBonus);
        }

        function showModal(title, desc, success, fuelBonus = 0) {
            document.getElementById('modal-title').innerText = title;
            document.getElementById('modal-title').className = success ? 'text-3xl font-bold text-green-400 mb-2' : 'text-3xl font-bold text-red-500 mb-2';
            document.getElementById('modal-desc').innerText = desc;
            
            const statsHtml = `
                <div>垂直速度: ${lander.vy.toFixed(2)} m/s</div>
                <div>水平速度: ${lander.vx.toFixed(2)} m/s</div>
                <div>角度: ${(lander.angle * 180 / Math.PI).toFixed(1)}°</div>
                <div>剩余燃料: ${Math.floor(lander.fuel)}%</div>
                ${success ? `<div>总耗时: ${lander.elapsedTime.toFixed(2)}s</div>` : ''}
                ${success && fuelBonus > 0 ? `<div class="text-yellow-400 font-bold">燃料奖励: +${fuelBonus}</div>` : ''}
            `;
            document.getElementById('modal-stats').innerHTML = statsHtml;

            modal.classList.add('active');
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function draw() {
            // 清空
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 画星星
            ctx.fillStyle = '#ffffff';
            stars.forEach(star => {
                ctx.globalAlpha = Math.random() * 0.5 + 0.3;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            // 画地形
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            for (let point of terrain) {
                ctx.lineTo(point.x, point.y);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.fillStyle = '#475569';
            ctx.fill();
            ctx.strokeStyle = '#94a3b8';
            ctx.stroke();

            // 画着陆平台 (高亮)
            const padX = canvas.width / 2 - LANDING_PAD_WIDTH / 2;
            const padY = canvas.height - 50;
            ctx.fillStyle = '#166534'; // green-800
            ctx.fillRect(padX, padY, LANDING_PAD_WIDTH, 10);
            ctx.strokeStyle = '#4ade80'; // green-400
            ctx.lineWidth = 2;
            ctx.strokeRect(padX, padY, LANDING_PAD_WIDTH, 10);
            
            // 平台标记文字
            ctx.fillStyle = '#4ade80';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('着陆区', canvas.width/2, padY + 25);

            // 画粒子
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.beginPath();
                ctx.arc(p.x, p.y, Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            // 画登月舱
            if (!lander.crashed) {
                ctx.save();
                ctx.translate(lander.x, lander.y);
                ctx.rotate(lander.angle);

                // 舱体 (主体)
                ctx.fillStyle = '#e2e8f0'; // slate-200
                ctx.beginPath();
                ctx.ellipse(0, 0, 12, 12, 0, 0, Math.PI*2); // 圆形驾驶舱
                ctx.fill();
                
                // 支架底座
                ctx.fillStyle = '#f59e0b'; // amber-500
                ctx.fillRect(-12, 5, 24, 6);

                // 脚架
                ctx.strokeStyle = '#94a3b8';
                ctx.lineWidth = 2;
                ctx.beginPath();
                // 左脚
                ctx.moveTo(-10, 8);
                ctx.lineTo(-18, 18);
                ctx.lineTo(-22, 18);
                // 右脚
                ctx.moveTo(10, 8);
                ctx.lineTo(18, 18);
                ctx.lineTo(22, 18);
                ctx.stroke();

                // 推进器火焰 (如果在推)
                if (lander.thrusting && Math.random() > 0.2) {
                    ctx.fillStyle = '#ef4444'; // red core
                    ctx.beginPath();
                    ctx.moveTo(-6, 11);
                    ctx.lineTo(0, 25 + Math.random() * 10);
                    ctx.lineTo(6, 11);
                    ctx.fill();
                }

                ctx.restore();
            }

            // 更新 HUD DOM
            updateHUD();
        }

        function updateHUD() {
            fuelBar.style.width = `${lander.fuel}%`;
            if (lander.fuel < 10) fuelBar.classList.replace('bg-green-500', 'bg-red-500');
            else fuelBar.classList.replace('bg-red-500', 'bg-green-500');

            // 高度 (反转坐标系)
            let alt = Math.max(0, (canvas.height - 50) - lander.y - 10).toFixed(0);
            altVal.innerText = alt;
            document.getElementById('score-val').innerText = score;
            document.getElementById('timer-val').innerText = lander.startTime > 0 ? lander.elapsedTime.toFixed(2) + 's' : '0.00s';


            // 速度与角度显示颜色逻辑
            const hSpeed = lander.vx.toFixed(1);
            const vSpeed = lander.vy.toFixed(1); // 正数向下
            const angleDeg = (lander.angle * 180 / Math.PI).toFixed(0);

            hSpeedVal.innerText = `${hSpeed} m/s`;
            hSpeedVal.className = Math.abs(lander.vx) > SAFE_HORIZONTAL_SPEED ? 'text-xl font-bold status-bad' : 'text-xl font-bold status-good';

            vSpeedVal.innerText = `${vSpeed} m/s`;
            vSpeedVal.className = (lander.vy > SAFE_LANDING_SPEED) ? 'text-xl font-bold status-bad' : 'text-xl font-bold status-good';

            angleVal.innerText = `${angleDeg}°`;
            angleVal.className = Math.abs(lander.angle) > SAFE_ANGLE ? 'text-xl font-bold status-bad' : 'text-xl font-bold status-good';
        }

        function loop() {
            if (gameState === 'PLAYING') {
                handleInput();
                updatePhysics();
            }
            updateParticles();
            draw();
            requestAnimationFrame(loop);
        }

        // 页面加载完成时：设置触摸控制和启动游戏
        window.onload = function() {
            setupTouchControls();
            initStars();
            generateTerrain();
            startGame(); // 显示初始的启动界面
            loop(); // 保持绘制循环以显示背景和HUD
        }

    </script>
</body>
</html>
