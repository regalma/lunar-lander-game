<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>登月模拟器 (Lunar Lander)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: #0f172a;
            color: #e2e8f0;
            overflow: hidden;
            touch-action: none; /* 防止移动端触摸滚动 */
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column; /* 手机模式下垂直布局 */
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
        }

        /* 调整 Canvas 大小以适应手机视图 */
        #gameCanvas {
            max-width: 100%;
            max-height: calc(100vh - 120px); /* 留出空间给底部控制按钮 */
            aspect-ratio: 8 / 6; /* 保持原始比例 */
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            border: 2px solid #334155;
            background-color: transparent;
        }

        .ui-overlay {
            position: absolute;
            pointer-events: none;
            /* HUD 尺寸与 Canvas 尺寸保持一致 */
            width: min(100%, 800px); 
            height: min(calc(100vh - 120px), 600px);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }
        
        /* 强制覆盖固定宽度，确保 HUD 内容不被压缩 */
        @media (min-width: 800px) {
            .ui-overlay {
                width: 800px;
                height: 600px;
            }
        }

        .hud-text {
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.7);
        }

        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 23, 42, 0.95);
            border: 2px solid #475569;
            padding: 2rem;
            text-align: center;
            border-radius: 1rem;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            pointer-events: auto;
            display: none; /* 默认隐藏 */
            min-width: 300px;
            z-index: 100;
        }

        .modal.active {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -40%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }

        .btn {
            background: #2563eb;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            text-transform: uppercase;
        }

        .btn:hover {
            background: #1d4ed8;
            transform: scale(1.05);
        }

        .status-good { color: #4ade80; }
        .status-warn { color: #facc15; }
        .status-bad { color: #ef4444; }

        /* 移动端控制布局 */
        .touch-controls {
            position: absolute;
            bottom: 0;
            width: min(100%, 800px); /* 与游戏画布保持宽度一致 */
            height: 120px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            pointer-events: auto;
            /* 桌面隐藏，手机显示 */
            display: none; 
        }

        /* 屏幕宽度小于 800px 时显示触摸控制 */
        @media (max-width: 799px) {
            .touch-controls {
                display: flex;
            }
            .controls-hint {
                display: none !important; /* 在手机上隐藏键盘提示 */
            }
        }
        
        .control-btn {
            background-color: rgba(30, 41, 59, 0.8); /* slate-800 semi-transparent */
            color: #fff;
            border: 2px solid #475569;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            touch-action: manipulation; /* 提高触摸响应 */
            transition: background-color 0.1s;
        }
        
        .control-btn:active, .control-btn.active-touch {
            background-color: #2563eb; /* blue-600 */
            border-color: #3b82f6;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }

        .side-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .main-thrust-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- 游戏画布 -->
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <!-- HUD 界面 -->
        <div class="ui-overlay">
            <div class="flex justify-between w-full">
                <div>
                    <div class="text-xl text-green-400 hud-text">FUEL</div>
                    <div class="w-32 h-4 bg-gray-800 border border-gray-600 mt-1">
                        <div id="fuel-bar" class="h-full bg-green-500 w-full transition-all duration-75"></div>
                    </div>
                </div>
                <div class="text-right">
                    <div class="text-xl text-green-400 hud-text">ALTITUDE: <span id="alt-val" class="text-white">1000</span></div>
                    <div class="text-sm text-gray-400">SCORE: <span id="score-val">0</span></div>
                </div>
            </div>

            <div class="flex justify-between items-end w-full">
                <div class="text-left">
                    <div class="text-sm text-gray-400">HORIZONTAL SPD</div>
                    <div id="h-speed" class="text-xl font-bold">0.0 m/s</div>
                </div>
                
                <!-- 姿态仪模拟 -->
                <div class="flex flex-col items-center">
                    <div class="text-xs text-gray-500 mb-1">ANGLE</div>
                    <div id="angle-val" class="text-xl font-bold">0°</div>
                </div>

                <div class="text-right">
                    <div class="text-sm text-gray-400">VERTICAL SPD</div>
                    <div id="v-speed" class="text-xl font-bold">0.0 m/s</div>
                </div>
            </div>
        </div>

        <!-- 结算弹窗 -->
        <div id="game-modal" class="modal">
            <h2 id="modal-title" class="text-3xl font-bold text-white mb-2">MISSION ACCOMPLISHED</h2>
            <p id="modal-desc" class="text-gray-300 mb-4">Perfect landing.</p>
            <div id="modal-stats" class="text-sm bg-gray-800 p-3 rounded mb-4 text-left font-mono">
                <!-- 统计数据 -->
            </div>
            <button class="btn" onclick="resetGame()">PLAY AGAIN</button>
        </div>
        
        <!-- 桌面控制提示 -->
        <div class="controls-hint absolute bottom-5 text-gray-500 text-xs opacity-60">
            Controls (Keyboard): [W/↑] Thrust | [A/D] Rotate | [←/→] Side Thrust
        </div>
        
        <!-- 移动端触摸控制区域 -->
        <div class="touch-controls">
            <!-- 左侧控制：侧推左 & 旋转左 -->
            <div class="side-controls">
                <button id="btn-side-left" class="control-btn">&#9664;</button> <!-- 左箭头 -->
                <div class="text-xs text-gray-400 text-center -mt-1">Side/H-Thrust</div>
                <button id="btn-rotate-left" class="control-btn text-xl">A</button>
                <div class="text-xs text-gray-400 text-center -mt-1">Rotate</div>
            </div>

            <!-- 中间控制：主推力 -->
            <div class="main-thrust-group">
                <div class="text-xl text-green-400 hud-text">THRUST</div>
                <button id="btn-thrust" class="control-btn w-20 h-20 text-3xl bg-green-700/80 border-green-400 hover:bg-green-600 active:bg-green-400 active-touch:bg-green-400">&#9650;</button> <!-- 上箭头 -->
                <div class="text-sm text-gray-400 mt-2">Tap/Hold to Start</div>
            </div>

            <!-- 右侧控制：侧推右 & 旋转右 -->
            <div class="side-controls">
                <button id="btn-side-right" class="control-btn">&#9654;</button> <!-- 右箭头 -->
                <div class="text-xs text-gray-400 text-center -mt-1">Side/H-Thrust</div>
                <button id="btn-rotate-right" class="control-btn text-xl">D</button>
                <div class="text-xs text-gray-400 text-center -mt-1">Rotate</div>
            </div>
        </div>

    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const fuelBar = document.getElementById('fuel-bar');
        const altVal = document.getElementById('alt-val');
        const hSpeedVal = document.getElementById('h-speed');
        const vSpeedVal = document.getElementById('v-speed');
        const angleVal = document.getElementById('angle-val');
        const modal = document.getElementById('game-modal');
        
        // 游戏常量
        const GRAVITY = 0.05;
        const THRUST_POWER = 0.12;
        const SIDE_THRUST_POWER = 0.05;
        const ROTATION_SPEED = 0.04;
        const LANDING_PAD_WIDTH = 120;
        const SAFE_LANDING_SPEED = 2.0; // 垂直速度阈值
        const SAFE_HORIZONTAL_SPEED = 1.0; // 水平速度阈值
        const SAFE_ANGLE = 0.2; // 弧度 (~11度)
        
        // 游戏状态
        let gameState = 'START'; // START, PLAYING, WON, CRASHED
        let particles = [];
        let stars = [];
        let terrain = [];
        let score = 0;

        // 登月舱对象
        const lander = {
            x: 400,
            y: 50,
            width: 20,
            height: 25,
            vx: 0,
            vy: 0,
            angle: 0,
            fuel: 100,
            thrusting: false,
            rotatingLeft: false,
            rotatingRight: false,
            sideThrustLeft: false,
            sideThrustRight: false,
            crashed: false,
            landed: false
        };

        // --- 输入处理状态 ---
        const keys = {};
        const touchState = {
            thrust: false,
            rotateLeft: false,
            rotateRight: false,
            sideThrustLeft: false,
            sideThrustRight: false
        };

        // --- 键盘事件监听 ---
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if(gameState === 'START') startGame();
        });

        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // --- 触摸事件监听 (Mobile) ---
        const buttons = {
            'btn-thrust': 'thrust',
            'btn-rotate-left': 'rotateLeft',
            'btn-rotate-right': 'rotateRight',
            'btn-side-left': 'sideThrustLeft',
            'btn-side-right': 'sideThrustRight',
        };

        function setupTouchControls() {
            Object.keys(buttons).forEach(id => {
                const btn = document.getElementById(id);
                const control = buttons[id];

                // Prevent mouse events from firing after touch events
                btn.addEventListener('mousedown', (e) => e.preventDefault()); 

                // Touch Start (Press Down)
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    touchState[control] = true;
                    btn.classList.add('active-touch');
                    if(gameState === 'START') startGame();
                }, { passive: false });

                // Touch End (Release)
                const releaseHandler = (e) => {
                    e.preventDefault();
                    touchState[control] = false;
                    btn.classList.remove('active-touch');
                };

                btn.addEventListener('touchend', releaseHandler, { passive: false });
                btn.addEventListener('touchcancel', releaseHandler, { passive: false }); // Important for when finger slides off
            });
        }
        
        // --- 主输入逻辑：合并键盘和触摸 ---
        function handleInput() {
            if (gameState !== 'PLAYING') return;

            // 旋转 (A/D or Touch)
            lander.rotatingLeft = keys['KeyA'] || touchState.rotateLeft;
            lander.rotatingRight = keys['KeyD'] || touchState.rotateRight;
            
            if (lander.rotatingLeft) lander.angle -= ROTATION_SPEED;
            if (lander.rotatingRight) lander.angle += ROTATION_SPEED;
            
            // 主引擎 (W/Up Arrow or Touch)
            lander.thrusting = (keys['KeyW'] || keys['ArrowUp'] || touchState.thrust) && lander.fuel > 0;
            
            // 侧推 (Left/Right Arrow or Touch)
            lander.sideThrustLeft = (keys['ArrowLeft'] || touchState.sideThrustLeft) && lander.fuel > 0;
            lander.sideThrustRight = (keys['ArrowRight'] || touchState.sideThrustRight) && lander.fuel > 0;

            if (lander.thrusting || lander.sideThrustLeft || lander.sideThrustRight) {
                lander.fuel = Math.max(0, lander.fuel - 0.2);
            }
        }

        // --- 游戏核心函数 (保持不变) ---
        
        function initStars() {
            stars = [];
            for(let i=0; i<150; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2,
                    brightness: Math.random()
                });
            }
        }

        function generateTerrain() {
            terrain = [];
            const padX = canvas.width / 2 - LANDING_PAD_WIDTH / 2;
            const segments = 20;
            const segmentWidth = canvas.width / segments;

            // 生成月球表面点
            for (let i = 0; i <= segments; i++) {
                let x = i * segmentWidth;
                let y;

                // 确保中间是平坦的着陆区
                if (x >= padX && x <= padX + LANDING_PAD_WIDTH) {
                    y = canvas.height - 50;
                } else {
                    // 随机地形，但稍微平滑一点
                    y = canvas.height - 50 - (Math.random() * 80); 
                }
                terrain.push({x, y});
            }
        }

        function resetGame() {
            lander.x = canvas.width / 2;
            lander.y = 80;
            lander.vx = (Math.random() - 0.5) * 1.5; // 随机初始水平速度
            lander.vy = 0;
            lander.angle = 0;
            lander.fuel = 100;
            lander.crashed = false;
            lander.landed = false;
            score = 0;
            
            particles = [];
            modal.classList.remove('active');
            gameState = 'PLAYING';
            
            generateTerrain();
            loop();
        }

        function startGame() {
            initStars();
            generateTerrain();
            resetGame();
        }

        function createParticle(x, y, angle, speed, life, color) {
            particles.push({
                x, y, 
                vx: Math.cos(angle) * speed + (Math.random() - 0.5), 
                vy: Math.sin(angle) * speed + (Math.random() - 0.5),
                life, 
                maxLife: life,
                color
            });
        }

        function updatePhysics() {
            if (gameState !== 'PLAYING') return;

            // 重力
            lander.vy += GRAVITY;

            // 主引擎推力 (沿着角度方向)
            if (lander.thrusting) {
                lander.vx += Math.sin(lander.angle) * THRUST_POWER;
                lander.vy -= Math.cos(lander.angle) * THRUST_POWER;

                // 产生粒子
                for(let i=0; i<3; i++) {
                    let bottomX = lander.x + Math.sin(lander.angle) * 15;
                    let bottomY = lander.y + Math.cos(lander.angle) * 15;
                    createParticle(bottomX, bottomY, lander.angle + Math.PI / 2 + (Math.random()-0.5), 3, 20, '#fbbf24');
                }
            }

            // 侧向推力 (RCS)
            // 左推 (ArrowLeft / Touch) -> 向左加速
            if (lander.sideThrustLeft) {
                lander.vx -= Math.cos(lander.angle) * SIDE_THRUST_POWER;
                lander.vy -= Math.sin(lander.angle) * SIDE_THRUST_POWER;
                // 粒子从右侧喷出
                createParticle(lander.x + Math.cos(lander.angle)*10, lander.y + Math.sin(lander.angle)*10, lander.angle + Math.PI, 1.5, 10, '#ffffff');
            }

            // 右推 (ArrowRight / Touch) -> 向右加速
            if (lander.sideThrustRight) {
                lander.vx += Math.cos(lander.angle) * SIDE_THRUST_POWER;
                lander.vy += Math.sin(lander.angle) * SIDE_THRUST_POWER;
                // 粒子从左侧喷出
                createParticle(lander.x - Math.cos(lander.angle)*10, lander.y - Math.sin(lander.angle)*10, lander.angle, 1.5, 10, '#ffffff');
            }

            // 更新位置
            lander.x += lander.vx;
            lander.y += lander.vy;

            // 边界检查 (左右循环)
            if (lander.x < 0) lander.x = canvas.width;
            if (lander.x > canvas.width) lander.x = 0;
            
            // 顶部阻挡
            if (lander.y < 0) {
                lander.y = 0;
                lander.vy = 0;
            }

            checkCollision();
        }

        function checkCollision() {
            const groundLevel = canvas.height - 50;
            
            if (lander.y + 10 >= groundLevel) {
                lander.y = groundLevel - 10;
                
                const padCenterX = canvas.width / 2;
                const onPad = Math.abs(lander.x - padCenterX) < (LANDING_PAD_WIDTH / 2);

                if (onPad) {
                    const safeSpeed = lander.vy < SAFE_LANDING_SPEED && Math.abs(lander.vx) < SAFE_HORIZONTAL_SPEED;
                    const safeAngle = Math.abs(lander.angle) < SAFE_ANGLE;

                    if (safeSpeed && safeAngle) {
                        gameWin();
                    } else {
                        let reason = "Unsafe Landing: ";
                        if (!safeSpeed) reason += `Speed: ${lander.vy.toFixed(1)} m/s (Max ${SAFE_LANDING_SPEED.toFixed(1)}) `;
                        if (!safeAngle) reason += `Angle: ${(lander.angle * 180 / Math.PI).toFixed(0)}° (Max ${(SAFE_ANGLE * 180 / Math.PI).toFixed(0)}°)`;
                        gameCrash(reason);
                    }
                } else {
                    gameCrash("Missed the Landing Zone");
                }
            }
        }

        function gameCrash(reason) {
            gameState = 'CRASHED';
            lander.crashed = true;
            for(let i=0; i<50; i++) {
                createParticle(lander.x, lander.y, Math.random() * Math.PI * 2, Math.random() * 5, 50, '#ef4444');
            }
            showModal('MISSION FAILED', `CRASHED: ${reason}`, false);
        }

        function gameWin() {
            gameState = 'WON';
            lander.landed = true;
            const fuelBonus = Math.floor(lander.fuel * 10);
            score += 1000 + fuelBonus;
            showModal('SUCCESS!', `Safe landing! Fuel Bonus: ${fuelBonus}`, true);
        }

        function showModal(title, desc, success) {
            document.getElementById('modal-title').innerText = title;
            document.getElementById('modal-title').className = success ? 'text-3xl font-bold text-green-400 mb-2' : 'text-3xl font-bold text-red-500 mb-2';
            document.getElementById('modal-desc').innerText = desc;
            
            const statsHtml = `
                <div>Vertical Speed: ${lander.vy.toFixed(2)} m/s</div>
                <div>Horizontal Speed: ${lander.vx.toFixed(2)} m/s</div>
                <div>Angle: ${(lander.angle * 180 / Math.PI).toFixed(1)}°</div>
                <div>Fuel Remaining: ${Math.floor(lander.fuel)}%</div>
            `;
            document.getElementById('modal-stats').innerHTML = statsHtml;

            modal.classList.add('active');
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function draw() {
            // 清空
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 画星星
            ctx.fillStyle = '#ffffff';
            stars.forEach(star => {
                ctx.globalAlpha = Math.random() * 0.5 + 0.3;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            // 画地形
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            for (let point of terrain) {
                ctx.lineTo(point.x, point.y);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.fillStyle = '#475569';
            ctx.fill();
            ctx.strokeStyle = '#94a3b8';
            ctx.stroke();

            // 画着陆平台 (高亮)
            const padX = canvas.width / 2 - LANDING_PAD_WIDTH / 2;
            const padY = canvas.height - 50;
            ctx.fillStyle = '#166534'; // green-800
            ctx.fillRect(padX, padY, LANDING_PAD_WIDTH, 10);
            ctx.strokeStyle = '#4ade80'; // green-400
            ctx.lineWidth = 2;
            ctx.strokeRect(padX, padY, LANDING_PAD_WIDTH, 10);
            
            // 平台标记文字
            ctx.fillStyle = '#4ade80';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('LANDING ZONE', canvas.width/2, padY + 25);

            // 画粒子
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.beginPath();
                ctx.arc(p.x, p.y, Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            // 画登月舱
            if (!lander.crashed) {
                ctx.save();
                ctx.translate(lander.x, lander.y);
                ctx.rotate(lander.angle);

                // 舱体 (主体)
                ctx.fillStyle = '#e2e8f0'; // slate-200
                ctx.beginPath();
                ctx.ellipse(0, 0, 12, 12, 0, 0, Math.PI*2); // 圆形驾驶舱
                ctx.fill();
                
                // 支架底座
                ctx.fillStyle = '#f59e0b'; // amber-500
                ctx.fillRect(-12, 5, 24, 6);

                // 脚架
                ctx.strokeStyle = '#94a3b8';
                ctx.lineWidth = 2;
                ctx.beginPath();
                // 左脚
                ctx.moveTo(-10, 8);
                ctx.lineTo(-18, 18);
                ctx.lineTo(-22, 18);
                // 右脚
                ctx.moveTo(10, 8);
                ctx.lineTo(18, 18);
                ctx.lineTo(22, 18);
                ctx.stroke();

                // 推进器火焰 (如果在推)
                if (lander.thrusting && Math.random() > 0.2) {
                    ctx.fillStyle = '#ef4444'; // red core
                    ctx.beginPath();
                    ctx.moveTo(-6, 11);
                    ctx.lineTo(0, 25 + Math.random() * 10);
                    ctx.lineTo(6, 11);
                    ctx.fill();
                }

                ctx.restore();
            }

            // 更新 HUD DOM
            updateHUD();
        }

        function updateHUD() {
            fuelBar.style.width = `${lander.fuel}%`;
            if (lander.fuel < 20) fuelBar.classList.replace('bg-green-500', 'bg-red-500');
            else fuelBar.classList.replace('bg-red-500', 'bg-green-500');

            // 高度 (反转坐标系)
            let alt = Math.max(0, (canvas.height - 50) - lander.y - 10).toFixed(0);
            altVal.innerText = alt;
            document.getElementById('score-val').innerText = score;

            // 速度与角度显示颜色逻辑
            const hSpeed = lander.vx.toFixed(1);
            const vSpeed = lander.vy.toFixed(1); // 正数向下
            const angleDeg = (lander.angle * 180 / Math.PI).toFixed(0);

            hSpeedVal.innerText = `${hSpeed} m/s`;
            hSpeedVal.className = Math.abs(lander.vx) > SAFE_HORIZONTAL_SPEED ? 'text-xl font-bold status-bad' : 'text-xl font-bold status-good';

            vSpeedVal.innerText = `${vSpeed} m/s`;
            vSpeedVal.className = (lander.vy > SAFE_LANDING_SPEED) ? 'text-xl font-bold status-bad' : 'text-xl font-bold status-good';

            angleVal.innerText = `${angleDeg}°`;
            angleVal.className = Math.abs(lander.angle) > SAFE_ANGLE ? 'text-xl font-bold status-bad' : 'text-xl font-bold status-good';
        }

        function loop() {
            if (gameState === 'START') {
                // 如果是移动端，触摸任何按钮即可开始
                return; 
            }

            handleInput();
            updatePhysics();
            updateParticles();
            draw();

            if (gameState === 'PLAYING') {
                requestAnimationFrame(loop);
            }
        }

        // 页面加载完成时：设置触摸控制和启动游戏
        window.onload = function() {
            setupTouchControls();
            resetGame();
        }

    </script>
</body>
</html>